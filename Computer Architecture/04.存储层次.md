# 存储层次

* 性能参数（两级）
  * 每位价格 C = (C1S1 + C2S2) / (S1 + S2)
    * S --容量
  * 命中率 hitratio H = N1 / (N1 + N2)
    * N1 --访问M1次数 N2
  * 失效率 miss ratio F = 1 - H
  * 平均访存时间TA
    * 命中时，访问时间为TA1，也称之为命中时间(hit time)
    * 不命中时TA = H\*TA1 + (i-H)(TA1 + TM) = TA1 + FTM
    * TM = TA2 + TB --失效开销miss penalty
    * TB --传送时间
* 两个存储层次
  * Cache-主存
  * 主存-辅存
* 存储层次的4个问题
  * 把一个块（页）调入高一层（靠近CPU）存储器时，可放置在那些位置上？（映像规则）
  * 当要访问的快（页）在高一层存储器中时，如何找到该块？（查找算法）
  * 当发生不命中，而且高一层存储器已满时，应替换哪一块（替换算法）
  * 当进行写访问时，应该进行哪些操作？（写策略）

## Cache 优化技术

### 降低Cache失效率的方法

* 失效的类型
  * 强制性失效 Compulsory miss
    * 又称冷启动失效
    * 当第一次访问一个块时，该块不在Cache中，必须会产生失效
  * 容量失效 Capacity
    * 程序执行时所需的块不能全部调入Cache中，则某些快被替换后又被访问，发生失效
  * 冲突失效 Conflict miss
    * 碰撞失效 Collision，首次访问失效
    * 组相联或直接映像Cache中，太多的块映像到同一组（块）中，出现某个快被替换随后又被访问的情况
* 结论
  * 相联度越高，冲突失效就越少
  * 强制性失效不受相联度、Cache容量的影响，容量失效随着容量的增加而减少
  * 符合2：1的Cache经验规则，大小为N的直接映像Cache生效率约等于大小为N/2的2路组相联Cahce的失效率
1. 增加Cache的大小
  * 直接减少了强制性失效，可能会增加冲突失效
2. 提高相联度
  * 提高相联度可能会导致命中时间的增加
3. 增加Cache的容量
  * 副作用增加成本 & 增加命中时间
4. 伪相联映像Cache
  * 命中时与直接映像Cache中相同
  * 发生失效时，检查另一个块，在访问下一级存储器之前
5. 硬件预取
  * 指令和数据都可以在处理器提出访问之前进行预取，预取内容可以直接放入Cahce，也可以放入一个外部缓冲器中
6. 编译器控制的预取
  * 在编译时加入预取指令，在数据使用前发出预取请求
7. Victim Cache
  * 在Cache和下一级存储器的数据通路之间增设一个全相联映像的小Cache
8. 编译器优化
  * 无需对硬件做任何改动就可以降低失效率

### 减少Cache失效开销的5种优化措施

1. 读生效优先于写
2. 写缓冲合并
3. 请求字处理技术
4. 非阻塞Cache技术
5. 采用俩级Cache

### 减少命中时间的4种方法

1. 容量小，结构简单的Cache
2. 虚拟Cache
3. Cache访问流水化
4. Trace Cache

---

## 主存

* 基本存储器结构的性能
  * 送地址需要4个时钟周期
  * 每个字访问时间为24个时钟周期
  * 传送一个字（32b）的数据需4个时钟周期
* 对于一般存储器(DRAM,SRAM等)均适用的4种技术
  * 增加存储器宽度
  * 采用简单的多体交叉存储器
  * 独立存储体
  * 避免存储体冲突
* 对于DRAM专用交叉结构
  * Nibble 方式：每次进行行访问时，DRAM除能够给出所需的位以外，还能给出其后的3位
  * Page 方式：缓冲器以SRAM的方式工作，即通过改变列地址，可以随机访问缓冲器内的任意以为，可反复进行，直至下一次访问或刷新
  * Static column 方式：与Page类似，只是在列地址改变时，无需触发列访问送通线
* 虚拟存储器
  * 是“主存-辅存”层次进一步发展的结果
  * 页式 虚拟存储器
    * 把空间划分为大小相同的块
  * 段式
    * 把空间划分为可变长的块
* 进程保护
  * 可以通过为每一个进程分配一个专用的页表，并使每个页表指向不同的存储器实现