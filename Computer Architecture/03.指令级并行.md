# 指令级并行

* 指令之间存在的潜在并行性称为指令级并行 Instruction-Level Parallelism,ILP
* CPI流水线 = CPI理想 + 三冲突停顿
* 解决”相关“问题
  * 保持相关，但避免发生冲突
  * 通过代码变换，消除相关
* 指令调度是一种用以避免冲突的主要方法，但它并不改变相关
* 对于正确的程序来说，必须保持最关键的两个属性
  * 数据流 data flow
  * 异常行为 exception behavior
    * 无论怎样改变指令的执行顺序，都不能改变程序中异常的发生情况
* 动态调度 dynamic scheduling
  * 在程序的执行过程中，依靠专门硬件对代码进行调度
* 乱序执行
  * 5段流水线译码段（ID）细分为两段 以支持乱序执行
  * 流出 Issue：指令译码，并检查是否有结构冲突；如果不存在结构冲突就将指令流出
  * 读操作数：等待数据冲突消失（如果存在），然后读操作数
  > 指令的流出仍然是按顺序流出，但在读操作数段可能停顿和相互跨越，因而进入执行段时变成乱序

## Tomasulo 算法

* 核心思想
  * 记录和检测指令相关，操作数一旦就绪就立即执行，把发生RAW冲突的可能减少到最小
  * 通过寄存器换名来消除WAR冲突和WAW冲突
  	* 由保留站和流出逻辑共同完成
* 分布的保留站
  * 冲突检测和指令执行机制是分布的，每个功能部件的保留站中的信息决定了什么时候指令可以在该功能部件开始执行
  * 计算结果通过CDB Common Data Bus 直接从产生它的保留站传递到所有需要它的功能部件，而不用经过寄存器

## 动态分支预测技术

### 分支历史表BHT Branch History Table

* 分支预测缓冲器BPB
* 记录最近一次或几次的执行情况（成功/不成功），并据此预测
* 一般采用两位分支预测
* BHT 状态机
	* 成功 00 -> 01 ---> 11
	  * 11，10
	* 不成功 11 -> 10 ---> 00
	  * 00，01
* 仅加快分支判断的速度，对分支地址计算无影响

### 分支目标缓冲器BTB　Branch Target Buffer

* 执行过的成功分支指令的地址
* 预测的分支目标地址（下一条/跳转地址）

### 基于硬件的前瞻执行

* 思想
  * 动态分支预测
  * 在控制相关的结果尚未出来之前，前瞻执行后续的指令
  * 用动态调度的方法，对基本块的各种组合进行跨基本块的调度
* 前瞻执行(speculation)对分支指令的结果进行猜测，并假设这个猜测总是对的
* 执行的结果并不写回到寄存器或存储器，而是放到一个称为ROB (ReOrder Buffer)的缓冲器中
* 等到相应的指令得到“确认”后，才将结果写入寄存器或存储器

#### ROB

* 指令类型
  * 指出该指令是分支指令，store指令或寄存器操作指令
* 目标地址
  * 给出指令执行结果应写入的目标寄存器号或存储器单元的地址
* 数据值字段
  * 用来保存指令前瞻执行的结果
* 就绪字段
  * 指出指令是否已经完成执行并且数据已就绪

* 多指令流出技术
* 多流出处理机的两个基本风格
  * 超标量 super scalar
    * 在每个时钟周期流出的指令条数不固定，依代码的拘役情况而定，但没有上限
  * 超长指令字VLIW Very Long Instruction Word
    * 流出指令条数固定，这些指令构成一条长指令或一个指令包
* 超标量处理机
  * 超标量结构对程序员是透明的